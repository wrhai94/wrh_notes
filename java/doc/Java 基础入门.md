# 学习方法
- 需求
  - 工作需要
  - 跳槽，公司要求
  - 技术控
- 看看是否能使用传统技术解决
  - 能解决，但不完美
  - 无法解决
- 引出学习的新技术和知识点
- 学习新技术或知识点的基本原理和基本语法
- 快速入门（基本程序）
- 开始研究技术的注意事项，使用细节，规范，优化。
  没有止境，程序员的能力区别。

# Java 概述
- sun 公司创建，创始人 gosling，2009年，甲骨文公司收购。
- 8，11 LTS（长期支持版）。

## Java 特性
1. 面向对象（oop）
2. Java 语言是健壮的。强类型机制、异常处理、垃圾自动收集等是 Java 程序健壮性的重要保证
3. 跨平台性（一个编译好的 class 文件可以在多个系统下运行）
4. 解释型
> 解释型语言：JavaScript、PHP、Java,编译性语言：C、C++
> 区别：解释型语言，编译后的代码不能直接被机器执行，需要解释器来执行，编译性语言编译后的代码，可以直接被机器执行。

## JDK（Java 开发工具包）
- JVM：jdk 中包含了 JVM，有了 JVM ，同一个 Java 程序就能在不同的操作系统中执行，实现了 Java 程序的跨平台性。
  1) 虚拟的计算机，具有指令集并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器，包含在 **JDK** 中。
  2) 不同平台有不同的虚拟机。
  3) 机制：屏蔽了底层运行平台的差别，实现“一次编译，到处运行”。
- JDK 基本介绍
  1. JDK = JRE + Java 的开发工具集（java,javac,javadoc 等）。
  2. 提供给 Java 开发人员使用。
- JRE 基本介绍
  1. JRE（java 运行环境），JRE = JVM + java 的核心类库。
  2. 如果要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。
- 为什么要配置环境变量
  - 为了在 DOS 的任意目录可以使用 java 和 javac 命令
  - 当前执行的程序在当前目录下如果不存在，win10 系统会在系统中已有的一个名为 path 的环境变量指定的目录中查找。如果仍未找到，会出现错误提示。

## 快速入门
- 控制台编译出现中文编码错误时，检查控制台编码和 Java 文件保存的编码是否一致。
- 运行机制
  .java 文件(源文件) -> javac 编译 -> .class 文件（字节码文件） -> java 运行（本质是把 .class 加载到 JVM 运行） -> 结果

## 开发细节，注意事项
- 一个源文件中最多只能有一个 public 类。
- 每一个类都对应一个 .class。
- 如果源文件中包含一个 public 类，则文件名必须与该类一致。
- 源文件中，非 public 也可以有 mian 方法。

## 转义字符
- 常用转义字符
  - \t:制表符
  - \n:换行
  - \\:\
  - \":"
  - \':'
  - \r:回车，System.out.println("王锐海在\r广州");//结果 广州海在
> 控制台使用<kbd>Tab</kbd>可以快速补齐文件名

## javadoc
- 文档注释 /** */
- javadoc -d f:\\temp\doc -author -version ChangeChar.java
- javadoc 标签

## 代码规范
- 缩进，选中代码，使用 <kbd>Tab</kbd> 整体向右移动，使用<kbd>Shift</kbd> + <kbd>Tab</kbd> 整体向左移动。
- 类和方法的注释要以 javadoc 的方式来写
- 非 javadoc 的注释，往往是给代码维护者看的
- 运算符和 = 左右两边加上空格
- 源文件用 utf-8 编码
- 行宽不要超过80字符
- 代码编写次行风格和尾行风格

## DOS命令
- 目录
  - 相对路径：从当前目录开始定位，..\..\a\b
  - 绝对路径：从根目录开始定位, d:\\a\b
  - ..\ 访问上一级目录
- 常用 dos 命令
  - dir：查看目录下的内容
    dir 或 dir 路径
  - cd：切换到其它盘需要 /D 开关
    cd .. 切换到上一级目录
    cd \ 根目录
  - tree 目录树
  - cls 清屏
  - exit 退出DOS
  - md 创建目录，rd 删除目录，copy 拷贝

# 变量
## 变量的注意事项
1. 变量表示内存中的一个存储区域（不同变量，类型不同，占用的空间大小不一样）。
2. 该区域有自己的名称和类型。
3. 变量必须先声明后使用。
4. 该区域的值可以在同一类型范围内变化。
5. 变量在同一作用域内不能同名。
6. 变量 = 变量名 + 值 + 数据类型。

## 数据类型
- Java 的数据类型（背）
  - ***基本数据类型***
    - 数值型
      - 整型
        - byte(字节)
      - 浮点型
    - 字符型：2个字节，存放单个字符，单引号'A'。
    - 布尔型
  - 引用数据类型
    - 类
    - 接口
    - 数组
- 整型细节
  1. 各整型有固定的范围和长度，不受具体 OS 的影响，以保证 Java 程序的可移植性。
  2. 整型常量（具体值）默认类型是 int，声明 long 常量需要在值后面加 'l' 或 'L'。
  3. Java 程序中常量声明为 int ,除非大数才使用 long。
  4. 计算机最小存储单位 bit，1 byte = 8 bit。
- 浮点类型
  - 浮点数 = 符号位 + 指数位 + 尾数位。
  - 尾数可能丢失，造成精度损失。
  - 细节
    - 默认 double 型，float 须加 'f'、'F'。
    - 2 种表现形式
      - 十进制数，如：5.12、512.0f 、.512（必须有小数点）
      - 科学计数法，如：5.12E2[5.12 * 10 的 2 次方]
    - 通常使用 double，因为精度高。
    - 运算小数可能会存在精度丢失的问题，所以在比较运算结果时，可能会不相等，如 2.7 和 8.1 / 3 比较。
      可以以两个数的差值的绝对值，在某个精度范围内比较，如
      if(Math.abs(2.7 - 8.1 / 3) < 0.000001) 差额非常小，认为相等。
- 字符型
  - 可以存放一个数字，输出Unicode码数字对应的字符，也可以强制类型转换为int输出。
  - 本质上存放一个数值，可以作为数值运算。
  - 字符型本质
    - 存储：'a' > 码值 97 > 二进制
      读取：二进制 > 97 > 'a'
    - 字符和码值的对应关系是通过字符编码表决定的
    > 常见编码表
    ASC 2：一个字节表示，128 个字符（实际上可以表示256，只用了128个）。
    Unicode：2 个字节表示（字母和汉字都是 2 个）。每个符号都给予唯一的编码，使用 Unicode 没有乱码的问题。缺点，因为统一 2 个字节，浪费存储空间。兼容 ASC 2。
    utf-8：互联网中使用广泛，大小可变的编码表，字母 1 个字节，汉字 3 个字节。
    gbk：字母 1 个字节，汉字 2 个字节
> Java API 中文在线文档 https://www.matools.com

## 基本数据类型转换
- 自动类型转换
  - char -> int
  - 注意
    - (byte,short) 和 char 之间不能相互自动转换。
      如果把一个具体的数值给 byte,编译器先判断这数值是否在 byte 范围内，如果是就可以。但先把数值赋给 int 变量，再把 int 变量赋给 byte 会报错，编译会先判断类型。
    - byte,short,char 可以计算，在计算时先转换为 int 类型(包括相同类型的运算，也会转换 int)。
      short s = 1;
      byte x = 1;
      short = s + x;  //err
    - boolean 不参与转换。
- 强制类型转换
  - 注意
    - 强转符号只针对最近的操作数有效。(int)10*3.5,只对 10 强转。
    - char 类型可以保存 int 的常量值，但不能保存 int 的变量值，需要强制类型转换。
- String 转换为基本数据类型，需要使用包装类。
- char和String的相互转换 
  - char 转 String
    1. String s = String.valueOf('c'); //效率最高的方法
    2. String s = String.valueOf(new char[]{'c'}); //将一个char数组转换成String
    4. String s = "" + 'c';
    5. String s = new Character('c').toString();
    6. String s = Character.toString('c');
    // Character.toString(char)方法实际上直接返回String.valueOf(char)
    
  - String 转 char
    1. 使用String.charAt(index)（返回值为char）可以得到String中某一指定位置的char。
    2. 使用String.toCharArray()（返回值为char[]）可以得到将包含整个String的char数组。这样我们就能够使用从0


# 运算符
## 算术运算符
- 取模的本质：a % b = a - a / b * b 
  如果 a 是小数时，公式 = a - (int)a / b * b
  *小数的运算，得到的结果是一个近似值
- 经典面试题：
  int i = 1;
  i = i++;  //规则使用临时变量：temp = i;i = i + 1;i = temp;
  i = ++i;  //规则使用临时变量：i = i + 1;temp = i;i = temp;
  
  int n = 10;
  int y = 10;
  i = i++ + ++i; //22:temp1 = i; i = i + 1; i = i + 1; temp2 = i; i = temp + temp2;
### 三元运算符
- 三元运算符是一个整体，注意自动转型（Object obj = true ? new Integer(1) : new Double(2.0)）。
- - -

## 逻辑运算符
### 逻辑 & 和短路 &&
- 对应 && 短路与而言，如果第一个条件为 false,后面的条件不会执行。如：if(a < 1 && ++b < 50),++b 可能不执行。
- 对应 & 逻辑与而言，如果第一个条件为 false,后面的条件仍会执行，++b 都会执行。
- 一般用短路与，提高效率。
### 逻辑 | 和短路 ||
- 区别同上。
### a ^ b 异或
- a 和 b 不同时为真，否则为假
### 练习
```java
		boolean x = true;
		boolean y = false;
		short z = 46;
		if ((z++ == 46) && (y = true))
			z++;
		if ((x = false) || (++z == 49))
			z++; 
		System.out.println(z);
```
### 赋值运算符，复合赋值运算符
- 复合赋值运算符会进行强制类型转换
  byte b = 3; b += 3;//等价 b = (byte)(b + 3);
  b++;//同理

## 标识符
- 变量、方法和类等命名的字符序列。
- 规则
  1. 字母、数字、下划线或'$'组成
  2. 数字不能开头
  3. 不能需要关键字和保留字
  4. 区分大小写
  5. 不能包含空格
- 规范
  1. 常量都用大写，下划线间隔单词。
  2. 大驼峰，小驼峰。

## 进制
- 二进制 以 0b 或 0B 开头
- 八进制 以 0 开头
- 十六进制 以 0x 或 0X 开头，此次 A~F 不区分大小写.
### 十进制转其他进制
### 其他进制转十进制
### 二进制转其他进制
- 二进制转八进制，将二进制每三位一组，转成对应的八进制。
- 二进制转十六进制，将二进制每四位一组，转成对应的八进制。
### 八进制转二进制
- 八进制数每一位转成对应3位的二进制。
### 十六进制转二进制
- 十六进制数每一位转成对应4位的二进制。

## 原码、反码和补码（重点难点，背）
1. 二进制的最高位是字符位：0表示正数，1表示负数。
2. 正数的原码，反码，补码都一样。
3. 负数的反码 = 它的原码字符位不变，其它位取反。
4. 负数的补码 = 它的反码 + 1，负数的反码 = 负数的补码 - 1。
5. 0 的反码，补码都是0 。
6. java 没有无符号数，即 Java 中的数都是有符号的
7. ***在计算机运算时，都是以补码的方式来运算***。
8. 当我们看到运算结果时，要看它的原码。

## 位运算
- 按位与 &
- 按位或 |
- 按位异或 ^
- 按位取反 ~
- 算术右移 >> ：1>>2 本质 1 / 2 / 2
- 算术左移 << ：1<<2 本质 1 * 2 * 2
- 逻辑右移 >>>
> 没有逻辑左移

# 流程控制
- 嵌套不要超过 3 层，可读性不好。
## switch
- 穿透
### 细节
  1. 表达式数据类型应和 case 后的常量类型一致，或可以自动互相转成能够相互比较的类型。
  2. switch (表达式)，表达式的返回值必须是byte、short、int、char、enum 或 String。
  3. case 子句中的值必须是常量或者是常量表达式，不能是变量。
  4. 可以没有 default 。
  5. break 使程序跳出 switch 语句块，如果没有 break ,程序会顺序执行到 switch 结尾。
### 思想
- 判断学生成绩大于 60 分，输出“及格”，否则不及格。
```java
// 可以使用(int)(score / 60) 就可以判断是否大于 60。
switch((int)(score / 60)){
  case 0 :
    System.out.println("不合格");
    break;
  case 1 :
    System.out.println("不合格");
    break;
}
```

## for
### 细节
1. 初始化和变量迭代可以写在其他地方。
   int i =0; 
   for(; 循环判断条件;){i++;}
2. 初始化可以有多条初始化语句，但要求类型一样。变量迭代也可以有多条。
   for (int i = 0, j = 0; i < 10; i++, j++){}

### 思想
- 由繁到简
- 先死后活

## 多重循环
- 建议使用 2 层，最多不要层 3 层。
## break
- 在多层嵌套语句中，可以通过标签指定要终止的是哪一层语句块（尽量不用，降低可读性）。

## 练习
- 水仙花数，取 各个位数的值，取第 i 位：n % 10 的i 次方 / 10 的 i-1 次方。 
- 输出 a~z: for(char c = 'a'; c <= 'z'; c++)

# 数组、排序、查找
## 数组
- 声明
  - int [] a;
  - int[] a = new int[100];
  - String[] a = {"a", "n"};
  - String[] a = new String[]{"a", "n"}; //[]中不能加大小
- 数组创建后，默认值
- ***值传递，引用传递（堆、栈）***

## 排序
- 排序分类
1. 内部排序
  指将需要处理的所有数据都加载到内部存储器中进行排序。
2. 外部排序
  数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。

- 冒泡排序

## 查找
1. 顺序查找
2. 二分查找（endIndex = midIndex - 1;beginIndex = midIndex + 1;）

## 二维数组
- 声明 int[][] y 或 **int[] y[]** 或 int y[][]
- 内存中如果表示
- 杨辉三角(思维)
- 思想
  - 在数组中插入一个值，新数组和旧数组可以分别用两个下标指示。

# 面向对象编程(基础)
## 类
### JVM内存中，对象的存在形式
- 栈中的对象变量存放对象在堆中的地址，堆中对象的基本数据类型的字段直接存放值，引用类型的字段存放方法区的常量池的地址。

## 类与对象
- 类和对象的内存分配机制
  - Java 内存的结构分析
    1. 栈：一般存放基本数据类型（局部变量）。
    2. 堆：存放对象。
    3. 方法区：常量池，类加载信息。
  - Java 创建对象的流程简单分析
    1. 加载类信息。
    2. 在堆中分配空间，进行默认初始化。
    3. 把地址赋给对象变量。
    4. 进行指定初始化。

## 成员方法
### 方法调用机制
<img src = "F:/note/file/java/MyJava/img/成员方法调用机制.png">


### 注意事项和使用细节
- 访问修饰符不写，为默认访问。
- 返回类型
  - 方法只有一个返回值。
- 形参列表
  - 方法定义时参数称为形式参数，方法调用时的参数称为实际参数。

## 递归
- 斐波那契
- 猴子偷桃
- 老鼠出宫
- 汉诺塔
- 八皇后

## 重载

## 可变参数
### 注意事项和使用细节
- 可变参数的实参可以是数组。
- 可变参数本质是数组。
- 可变参数可以0或多个。
- 可变参数必须保证在参数列表最后。
- 一个形参列表中只能有一个可变参数。

## 作用域
### 注意事项和使用细节
- 全局变量可以加修饰符，局部变量不能加修饰符。

## 构造器
- 构造器没有返回值
- 构造器是完成对新对象的初始化，不是创建对象。
- this()

### 注意事项和使用细节
- 没有定义构造器，系统会自动给类生成一个默认的无参构造器，javap 命令可以反编译看到。
- 一旦定义了有参构造器，会覆盖默认的无参构造器。如果还有使用无参构造器，需要显式的定义无参构造器。

## 对象创建的流程分析
- 方法区加载类信息，只会加载一次。
- 在堆中分配空间。
- 完成对对象的初始化。
- 对象在堆中的返回给对象变量。

## this
- this 的引用的地址 就是 this 指示的对象引用的地址。

# 面向对象编程（中级）
## IDEA
### 设置
- 设置字体
  - 菜单 file - settings - Appearance
                           Editor - Font
- 字符编码设置
  - file - settings - File Encodings
  - 设置 UTF - 8 

### 常用快捷键
- 修改快捷键， settings - Keymap
1. 删除当前行(delete line) 默认<kbd>ctrl</kbd> + <kbd>Y</kbd>
2. 复制当前行（duplicate line or Selection）
3. 补齐代码，<kbd>Alt</kbd> + <kbd>/</kbd>
4. 注释，<kbd>Ctrl</kbd> + <kbd>/</kbd>
5. 导入该行需要的类，先配置 auto import,使用<kbd>alt</kbd> + <kbd>enter</kbd>
6. 快速格式化代码，<kbd>Ctrl</kbd> + <kbd>Alt</kbd>+ <kbd>L</kbd>
7. 快速运行（Run），自定义<kbd>Ctrl</kbd> + <kbd>R</kbd>
8. 构造器，重写方法等，  <kbd>Alt</kbd>+ <kbd>Insert</kbd>
9. 把光标放在类上，查看类的层级关系，<kbd>Ctrl</kbd> + <kbd>H</kbd>
10. 把光标放在方法上，快速定位方法，<kbd>Ctrl</kbd> + <kbd>B</kbd>
11. 自动分配变量名，在后面加.var。
12. 用 if、for、while、try...catch... 等将代码包起来 <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>T</kbd>
13. 打开类或资源， <kbd>Ctrl</kbd> + <kbd>N</kbd> / <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>N</kbd> 
  
### 模板
- file - settings - eidtor - Live templates

## 包
- 命名规则
- 只能包含数字、字母、下划线、点，不能以数字开头，不能是关键字或保留字。
## 常用包
- java.lang.* //基本包，默认引入
- java.util.* //系统提供的工具包
- java.net.*  //网络包，网络开发1
- java.awt.*  //java界面开发，GUI
  
## 使用细节
- 建议只导入需要的类，不要使用 *。

## 访问修饰符
1. 公开级别，public
2. 受保护级别，protected，对子类和同包中的类开放。
3. 默认级别，没有修饰符，向同包的类开放
4. 私有级别，private

### 注意
1. 只有默认的和public 才能修饰类

## 面向对象编程 - 封装 （encapsulate）

## 面向对象编程 - 继承
### 注意事项和使用细节
1. 子类必须调用父类的构造器，完成父类的初始化。
2. 当创建子类对象时，使用子类的任何构造器，默认情况都会调用父类的无参构造器，如果子类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器（必须使用父类其中一个构造器）完成对父类的初始化工作，否则，编译不通过。
3. 使用 super 调用构造器的语句必须是子类构造器的第一句。
4. this() 和 super() 都要放在构造器的第一句，所以只能二选一使用。
5. is-a

### 继承的本质
<img src = "F:/note/file/java/MyJava/img/继承机制.png">

### super
1. 调用父类构造器的好处，分工明确，父类属性由父类初始化，子类属性由子类初始化。
2. 子类属性或方法和父类重名，可以通过 super 跳过本类属性或方法直接访问父类属性。如果没有重名，super、this、直接访问的效果是一样的。（如果本类没有该方法或属性，会到父类找，父类如果还没有会一直向其父类找，直到找或所有父类都找不到为止，如果找到第一个同名属性或方法，但访问级别为无法访问，则报错。）
3. 继承的本质就是建立一个查找的关系，使用 super 访问父类属性或方法遵循就近原则。

### 方法重写
#### 注意事项和使用细节
1. 子类方法的返回类型和父类方法返回类型一样，或是父类返回类型的子类。
2. 子类方法的范围权限不能小于父类方法的访问权限。

#### 区分重载和重写

## 面向对象编程 - 多态
- 方法或对象具有多种形态，多态建立在继承和封装的基础上。
- 方法多态
  - 重写和重载。
- 对象的多态（核心，背）
  1. 一个对象的编译类型和运行类型可以不一致（编译类型是父类，运行类型是子类）。
  2. 编译类型在定义对象时，就确定了，不能改变。
  3. 运行类型是可以改变的（父类对象变量  a = new 子类A; a = new 子类B;）。
  4. 编译类型看 = 号左边，运行类型看 = 号右边

### 注意和细节
1. 向上转型
   1) 父类 a = new 子类;
   2) 可以调用父类中的所有允许访问的成员
   3) 不能调用子类的特有成员，因为编译阶段，能调用那些成员，由编译器决定。
   4) 最终运行效果看子类的实现
2. 向下转型
   1) 子类 a = (子类)父类引用;
   2) 只能强转父类引用，不能强转父类的对象。
   3) 要求父类的引用必须指向的是当前的目标类型的对象（Object num = new Integer(5);String numStr = (String) num;//err）。
   4) 向下转型后，可以调用子类类型的所有成员。
3. 属性没有重写之说，属性的值看编译类型（编译类型是父类，父类引用.属性 = 父类中属性的值）。
4. instanceOf 比较操作符，用于判断对象的运行类型是否为某类或某类的子类。

## 动态绑定机制
1. 当调用对象方法的时候，该方法会和对象的内存地址/运行类型绑定。
2. 当调用对象属性时，没有动态绑定机制，哪里声明，哪里调用。

## equals

## hashCode

## toString

## finalize
1. 当对象被回收时，系统会自动调用该对象的 finalize 方法。子类可以重写这个方法，做一些释放资源的操作。
2. 当某个对象没有任何引用时，jvm 就认为这个对象是一个垃圾对象，使用垃圾回收机制销毁对象，销毁对象前，会调用该对象的 finalize 方法。
3. 垃圾回收机制的调用，是由系统来决定（GC算法），也可以通过 System.gc() 主动触发垃圾回收机制。

## 调试
- IDEA 默认调试无法进入java.* 下的方法，可以在 file - setting - Build,Execution...  - Debugger - Stepping - Do not step into classes,取消 java.* 的勾。
- IDEA <kbd>shift</kbd> + <kbd>F8</kbd> 跳出当前方法，返回到上层方法。

# 项目实例
## 框架图（分层模式）
1. 系统有哪些类型。
2. 明确类与类的调用关系。
## 分层模式
- 界面层
- 业务层
- domain/model/数据层