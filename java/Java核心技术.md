# 学习方法
- 需求
  - 工作需要
  - 跳槽，公司要求
  - 技术控
- 看看是否能使用传统技术解决
  - 能解决，但不完美
  - 无法解决
- 引出学习的新技术和知识点
- 学习新技术或知识点的基本原理和基本语法
- 快速入门（基本程序）
- 开始研究技术的注意事项，使用细节，规范，优化。
  没有止境，程序员的能力区别。
- - -
# Java 概述
- sun 公司创建，创始人 gosling，2009年，甲骨文公司收购。
- 8，11 LTS（长期支持版）。

## Java 特性
1. 面向对象（oop）
2. Java 语言是健壮的。强类型机制、异常处理、垃圾自动收集等是 Java 程序健壮性的重要保证
3. 跨平台性（一个编译好的 class 文件可以在多个系统下运行）
4. 解释型
> 解释型语言：JavaScript、PHP、Java,编译性语言：C、C++
> 区别：解释型语言，编译后的代码不能直接被机器执行，需要解释器来执行，编译性语言编译后的代码，可以直接被机器执行。
- - -

## JDK（Java 开发工具包）
- JVM：jdk 中包含了 JVM，有了 JVM ，同一个 Java 程序就能在不同的操作系统中执行，实现了 Java 程序的跨平台性。
  1) 虚拟的计算机，具有指令集并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器，包含在 **JDK** 中。
  2) 不同平台有不同的虚拟机。
  3) 机制：屏蔽了底层运行平台的差别，实现“一次编译，到处运行”。
- JDK 基本介绍
  1. JDK = JRE + Java 的开发工具集（java,javac,javadoc 等）。
  2. 提供给 Java 开发人员使用。
- JRE 基本介绍
  1. JRE（java 运行环境），JRE = JVM + java 的核心类库。
  2. 如果要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。
- 为什么要配置环境变量
  - 为了在 DOS 的任意目录可以使用 java 和 javac 命令
  - 当前执行的程序在当前目录下如果不存在，win10 系统会在系统中已有的一个名为 path 的环境变量指定的目录中查找。如果仍未找到，会出现错误提示。
- - -

## 快速入门
- 控制台编译出现中文编码错误时，检查控制台编码和 Java 文件保存的编码是否一致。
- 运行机制
  .java 文件(源文件) -> javac 编译 -> .class 文件（字节码文件） -> java 运行（本质是把 .class 加载到 JVM 运行） -> 结果
### 转义字符
- 常用转义字符
  - \t:制表符
  - \n:换行
  - \\:\
  - \":"
  - \':'
  - \r:回车，System.out.println("王锐海在\r广州");//结果 广州海在
> 控制台使用<kbd>Tab</kbd>可以快速补齐文件名

### 代码规范
- 缩进，选中代码，使用 <kbd>Tab</kbd> 整体向右移动，使用<kbd>Shift</kbd> + <kbd>Tab</kbd> 整体向左移动。
- 类和方法的注释要以 javadoc 的方式来写
- 非 javadoc 的注释，往往是给代码维护者看的
- 运算符和 = 左右两边加上空格
- 源文件用 utf-8 编码
- 行宽不要超过80字符
- 代码编写次行风格和尾行风格

### DOS命令
- 目录
  - 相对路径：从当前目录开始定位，..\..\a\b
  - 绝对路径：从根目录开始定位, d:\\a\b
  - ..\ 访问上一级目录
- 常用 dos 命令
  - dir：查看目录下的内容
    dir 或 dir 路径
  - cd：切换到其它盘需要 /D 开关
    cd .. 切换到上一级目录
    cd \ 根目录
  - tree 目录树
  - cls 清屏
  - exit 退出DOS
  - md 创建目录，rd 删除目录，copy 拷贝
- - -

# Java的基本程序设计结构
- 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

## 数据类型
- java是一种强类型语言
### 8种基本类型
#### 4种整型
- byte(字节) 1字节(-128~127)
- short 2字节(-32768~32767)
- int 4字节(刚超过20亿)
- long 8字节

- 整型细节
  1. 各整型有固定的范围和长度，不受具体 OS 的影响，以保证 Java 程序的可移植性。
  2. 整型常量（具体值）默认类型是 int，声明 long 常量需要在值后面加 'l' 或 'L'。
  3. Java 程序中常量声明为 int ,除非大数才使用 long。
  4. 计算机最小存储单位 bit，1 byte = 8 bit。
  5. 可用下划线增加可读性，如1_000_000


#### 2种浮点型
- float 4字节(有效位数为6~7)
- double 8字节(有效位数为15位)

- 细节
  - 浮点数 = 符号位 + 指数位 + 尾数位。
  - 尾数可能丢失，造成精度损失。
  - 细节
    - 默认 double 型，float 须加 'f'、'F'。
    - 2 种表现形式
      - 十进制数，如：5.12、512.0f 、.512（必须有小数点）
      - 科学计数法，如：5.12E2[5.12 * 10 的 2 次方]
    - 通常使用 double，因为精度高。
    - 运算小数可能会存在精度丢失的问题，所以在比较运算结果时，可能会不相等，如 2.7 和 8.1 / 3 比较。
      可以以两个数的差值的绝对值，在某个精度范围内比较，如
      if(Math.abs(2.7 - 8.1 / 3) < 0.000001) 差额非常小，认为相等。

> 遵循IEEE754，表示溢出和出错情况的三个浮点数值
>  - 正无穷大
>  - 负无穷大
>  - NaN(不是一个数字) 

> 警告
> 浮点数值不适用于无法接受舍入误差的金融计算，如2.0-1.1 = 0.89999...，这种误差是因为浮点数值采用二进制系统表示，而二进制无法精确表示1/10


#### 1种字符型char ？
- 2个字节，存放单个字符，单引号'A'。
- 可以存放一个数字，输出Unicode码数字对应的字符，也可以强制类型转换为int输出。
- 本质上存放一个数值，可以作为数值运算。
- 字符型本质
  - 存储：'a' > 码值 97 > 二进制
    读取：二进制 > 97 > 'a'
  - 字符和码值的对应关系是通过字符编码表决定的
  > 常见编码表
  ASC 2：一个字节表示，128 个字符（实际上可以表示256，只用了128个）。
  Unicode：2 个字节表示（字母和汉字都是 2 个）。每个符号都给予唯一的编码，使用 Unicode 没有乱码的问题。缺点，因为统一 2 个字节，浪费存储空间。兼容 ASC 2。
  utf-8：互联网中使用广泛，大小可变的编码表，字母 1 个字节，汉字 3 个字节。
  gbk：字母 1 个字节，汉字 2 个字节
#### 1种boolean类型
- - -

## 变量和常量
### 声明变量
- 变量必须以字母开头并由字母（大小写字母、'_'、'$'）和数字构成，大小写敏感，变量名长度基本没有限制
### 变量初始化
- 变量声明后，必须用赋值语句对变量进行显式初始化，不能用未初始化的变量值
- 良好的编程习惯，变量的声明尽量靠近第一次使用的地方

### 变量的注意事项
1. 变量表示内存中的一个存储区域（不同变量，类型不同，占用的空间大小不一样）。
2. 该区域有自己的名称和类型。
3. 变量必须先声明后使用。
4. 该区域的值可以在同一类型范围内变化。
5. 变量在同一作用域内不能同名。
6. 变量 = 变量名 + 值 + 数据类型。


### 常量
- final表示变量只能被赋值一次，习惯上使用全大写
- 类常量：常量在一个类中的多个方法中使用

### 数值类型之间的转换
- 可能精度丢失的转换：long>double, long>float, int>float
- 二元运算符连接两个值时，会先转换为同一种类型，再进行运算
- 自动类型转换
  - char -> int
  - 注意
    - (byte,short) 和 char 之间不能相互自动转换。
      如果把一个具体的数值给 byte,编译器先判断这数值是否在 byte 范围内，如果是就可以。但先把数值赋给 int 变量，再把 int 变量赋给 byte 会报错，编译会先判断类型。
    - byte,short,char 可以计算，在计算时先转换为 int 类型(包括相同类型的运算，也会转换 int)。
      short s = 1;
      byte x = 1;
      short = s + x;  //err
    - boolean 不参与转换。

### 强制类型转换
```java
// 可能会丢失信息（cast）
double x = 9.99
int nx = (int)x; // 结果：9
```
```java
// 使用Math.round获取四舍五入
double x = 9.99
int nx = (int)Math.round(x); // 结果：10
```
- 注意
  - 强转符号只针对最近的操作数有效。(int)10*3.5,只对 10 强转。
  - char 类型可以保存 int 的常量值，但不能保存 int 的变量值，需要强制类型转换。
- - -

## 运算符
### 算术运算符
- 除 '/'
  - 整数除法：运算2个操作数都是整数，15/2=7
  - 浮点除法：15.0/2=7.5
- 取模的本质：a % b = a - a / b * b 
  如果 a 是小数时，公式 = a - (int)a / b * b
  *小数的运算，得到的结果是一个近似值
- 经典面试题：
  int i = 1;
  i = i++;  //规则使用临时变量：temp = i;i = i + 1;i = temp;
  i = ++i;  //规则使用临时变量：i = i + 1;temp = i;i = temp;
  
  int n = 10;
  int y = 10;
  i = i++ + ++i; //22:temp1 = i; i = i + 1; i = i + 1; temp2 = i; i = temp + temp2;
### 三元运算符
- 三元运算符是一个整体，注意自动转型（Object obj = true ? new Integer(1) : new Double(2.0)）。

### 逻辑运算符
#### 逻辑 & 和短路 &&
- 对应 && 短路与而言，如果第一个条件为 false,后面的条件不会执行。如：if(a < 1 && ++b < 50),++b 可能不执行。
- 对应 & 逻辑与而言，如果第一个条件为 false,后面的条件仍会执行，++b 都会执行。
- 一般用短路与，提高效率。
#### 逻辑 | 和短路 ||
- e1 || e2:e1表达式为true,e2无需计算，e1 || e2值为true
- 区别同上。
#### a ^ b 异或
- a 和 b 不同时为真，否则为假
#### 练习
```java
		boolean x = true;
		boolean y = false;
		short z = 46;
		if ((z++ == 46) && (y = true))
			z++;
		if ((x = false) || (++z == 49))
			z++; 
		System.out.println(z);
```
### 赋值运算符，复合赋值运算符（结合赋值）
- 复合赋值运算符会进行强制类型转换
  byte b = 3; b += 3;//等价 b = (byte)(b + 3);
  b++;//同理
```java 
        //在赋值中使用二元运算符,%=、*=、+=
        int x =1;
        x += 4; //结果：5
        //两侧操作数类型不同，会向左侧强制类型转换
        x += 1.5; //结果：6
```

### 数学函数与常量
- Math类提供各种数学函数
- floorMod
```java
// 不必加Math前缀，可以加上这行代码
import static java.lang.Math.*;
```

### 关系和boolean运算符
- ==、!=、<、>等

### 位运算符？
### 括号与运算符级别
- - -

## 字符串
- Java字符串就是Unicode字符序列，Java没有内置的字符串类型，
  而是在标准Java类库中提供预定义类String
### 子串 substring
### 拼接
- "e1" + "e2"
- 字符串与非字符串拼接，后者会转换成字符串
- 多字符串拼接 String.join("1", "a", "b")
- "j".repeat // jjj

### 不可变字符串
- String类对象是不可变的(immutable)，如字符串"hi"永远包含字符h,i的代码单元序列。
  工作方式，各种字符串存放在公共存储池中，字符串变量指向存储池中相应的位置，
  如复制字符串变量，2个变量共享相同的字符。
  效率，设计者认为共享带来的高效率远胜与提取、拼接字符串降低的效率。
- String 转换为基本数据类型，需要使用包装类。
  ```java
  //定义一个 str 对象，字面量为 "14"
  String str = "14";
  // 1) 利用基本数据类型对应包装类的parseXXX()方法进行转化 成基本数据类型
  int strIntValue = Integer.parseInt(str);
  //float flat = Float.parseFloat(str)
 
  // 2) 利用 基本数据类型对应包装类的valueof()方法进行转化成基本数据类型
  int strIntValue1 = Integer.valueOf(str);  //方法返回值是Integer类型,会自动拆箱转化成int类型
 
  System.out.println(strIntValue+"\n"+strIntValue1+"\n");
  ```

- char和String的相互转换 
  - char 转 String
    1. String s = String.valueOf('c'); //效率最高的方法
    2. String s = String.valueOf(new char[]{'c'}); //将一个char数组转换成String
    3. String s = "" + 'c';
    4. String s = new Character('c').toString();
    5. String s = Character.toString('c');
    // Character.toString(char)方法实际上直接返回String.valueOf(char)
    
  - String 转 char
    1. 使用String.charAt(index)（返回值为char）可以得到String中某一指定位置的char。
    2. 使用String.toCharArray()（返回值为char[]）可以得到将包含整个String的char数组。

### 检测字符串是否相等
- equals
- equalsIgnoreCase,不区分大小写
- == 只能检测两个字符串是否存放在同一个位置上，两个内容相同的字符串可能存放在不同位置。
  虚拟机实际自由字符串字面量是共享的，而+或substring等操作获取的字符串并不共享，使用==可能会导致间歇性BUG。

### 码点与代码单元
- 字符串有char值序列组成，char是一个采用UTF-16编码表示Unicode码点的代码单元。
- 代码单元数量 str.length();
- 获取实际长度，码点数量 str.codePointCount(0, str.length());
- str.charAt(n),返回位置n的代码单元
- 有一些字符需要两个代码单元
- ```java
        //codePoints方法生成一个int值的流，每个int对应一个码点
        int [] codePoints = c.codePoints().toArray();
        for(int codePoint:codePoints){
            System.out.println(codePoint);
        }
        //转换成数组
        String str = new String(codePoints, 0, codePoints.length);
        System.out.println(str);
  ```

### String ApI p49
### 构造字符串 StringBuilder
- 多个字符串拼接，每拼接一个字符串都要构建一个String,即耗时，又浪费空间。
- - -

## 标识符
- 变量、方法和类等命名的字符序列。
- 规则
  1. 字母、数字、下划线或'$'组成
  2. 数字不能开头
  3. 不能使用关键字和保留字
  4. 区分大小写
  5. 不能包含空格
- 规范
  1. 常量都用大写，下划线间隔单词。
  2. 大驼峰，小驼峰。
- - -

## 输入与输出
### 控制台输入 System.in
### 格式化输出 P57
- String.format("Helle %s.", name);
- %后面可以跟索引,已\$结束，如String.format("%1\$s %2\$s %2\$s.", name, age);
- <表示前面格式说明中的参数被再次使用，String.format("%s %s %<s.", name, age);
- - -

## 控制流程
### 块作用域
```java
    //块的概念：由若干条语句组成的语句，并用大括号括起来。块确定了变量的作用域。
    private static void testBlock (){
        int n;
        {
          int k;
          int n;
          System.out.println("块里面");
        }
    }
```
### 条件语句
- if(conditon) statement//可以是块
### 循环
- while(condition) statement
- do statement while(contidion);
### 确定循环
- for循环，for语句中声明的变量，作用域扩展到for循环体中。
### 多重选择：switch
### 中断控制流程的语句
- break,可以带标签，标签必须在下午跳出的最外层循环前
- continue
- - -

## 大数
- BigInteger和BigDecimal:可以处理包含任意长度数字序列的数字。
  大数不能使用算术运算符

## 数组
### 声明数组
- 数组是一种数据结构，用于存储同一类型值的集合，数组一旦创建，就不能改变它的长度。
  int[] a;//未初始化
  int[] a = new int[10];//初始化可以存储10个整数的数组
  int[] a = {1,2};
  new int[]{1,2};//匿名数组
### 访问数组元素
- 创建数字数组时，所有元素初始值为0。
- boolean数组的元素初始值为false
- 对象数组初始值为null,如String[] name = new String[10];
### for each
- for(uariable:collection) statement
- Arrays.toString(a)
### 数组拷贝
- Arrays.copyOf(a, a.length)
  可用于增加数组大小和只截取前面的值。
### 数组排序
- Arrays.sort(a),使用快速排序算法
- - -

# 对象与类
## 面向对象程序设计概述
- 面向对象程序设计（object-oriented programming OOP）
### 类
- 类(class)是构建对象的模板，构建(constract)过程称为创建类的实体（instance）
- 封装（encapsulation）是将数据和行为组合在一个包中，
  并对对象使用者异常具体实现方式。
  对象中数据称为$实例字段$（instance field），
  操作数据的过程称为$方法$（method）。
  一组特定实例字段值的集合就是这个对象的状态（state）。
- 实现封装的关键：绝对不能让类中的方法访问其他类的实例字段。
  程序只能通过对象的方法与对象进行数据交互（黑盒特征），
  这是提高重用性和可靠性的关键。
  这样类可以改变存储数据的方式，其他对象不用关系这个类发生的变化。
- 扩展一个类建立另一个类的过程称为继承（inheritance）
### 对象
- 三个特征
  - 对象的行为（behavior）
  - 对象的状态（state）
  - 对象的标识（identity）
- 对象的状态的改变***必须通过调用方法实现***，
  不经过方法调用改变对象状态，只能声明破坏了封装性
- 一个源文件中最多只能有一个 public 类。
- 每一个类都对应一个 .class。
- 如果源文件中包含一个 public 类，则文件名必须与该类一致。
- 源文件中，非 public 也可以有 mian 方法。
### 识别类
- 类名用名称
- 方法用动词
### 类之间的关系
- 依赖（dependence）
  - 一个类的方法中使用或操作另一个类的对象，
    前者没有后者类型的属性
- 聚合（aggregation）
  - 强关联关系，整体与部分，类A包含类B
- 继承（inheritance）
- - -

## 预定义类
### 对象和对象变量
- 使用构造器构造新实例。
  构造器的名字应该与类名相同。
  构造一个对象：new 构造器。
  变量不是一个对象，如 Date d,没有引用如何对象。
  对象变量没有实际包含一个对象，它只是引用了一个对象，
  多个对象变量可以引用同一个变量。
### LocalDate类
- 表示时间点Date
- 日历表示法表示日期LocalDate
- Java将时间度量和日历分开，P99
### 改变器方法和访问器方法
- 改变器方法：会改变对象状态的方法
- 访问器方法：只访问对象而不修改对象的方法
- - -

## 自定义类
- 在一个源文件中，只有一个公共类，
  可以有任意数量的非公共类。
  编译时会在目录下根据类的数量生成相应数量的类文件。
  Test1.class
  Test1$c1.class
### 多个源文件
- 如 Employee.java和 EmployeeTest.java
  两种编译方式
  - 使用通配符
    javac Employee*.java
  - javac EmployeeTest.java
    编译器会将 EmployeeTest 类中使用的 Employee 也进行编译，
    编译会查找 Employee.class,如果没有找到，会自动搜索
    Employee.java， 然后对他进行编译，如果 Employee.java
    较 Employee.class版本更新，也会自动重新编译。
### var
- java 10
- 方法中只能用于局部变量，不允许定义类的成员变量
- 不推荐对数值类型使用
- var 定义变量必须赋初始值
- var每次只能定义一个变量，不能复合声明变量
### null
#### 给非null值传null的2种解决方法
```java
//宽松型
if (n == null) name = "unknown" else name = n;
// java 9 提供
name = Objects.requireNonNullElse(name, "unknown");
```
```java
//严格型
/*
好处：
1.异常报告会提供问题描述
2.准确单位异常位置
*/
Objects.requireNonNull(name, "名字不允许为空");
```
### 隐式参数和显式参数
- num.raiseSalary(5)
  num 称为隐式参数，没有出现在方法声明中，每个方法中 this 指示隐式参数。
  5 称为显式参数，显式地列在方法声明中。
### 封装的优点
- 只读字段在构造器中设置后，可以确保不会受外界破坏
- 非只读字段，只能在该类的方法中修改，一旦出现错误调试这些方法就可以了
- 改变内部实现，除了影响该类方法，对外部其他代码不影响
- ***警告***：不要编写返回可变对象的访问器。
  如返回 Date 类型的字段，Date 类型有个更改器setTime，
  外部会和内部的对象变量引用同一个对象，
  外部调用更改器会自动改变内部的私有状态。
  返回可变对象的引用，应该先对它进行**克隆**
  return b.clone();
### 基于类的访问权限
```java 
//一个类的方法可以访问任何同类型对象的私有字段
public class Employee {
    private String name;
    public boolean equals2(Employee other){
        return this.name.equals(other.name);
    }
}
```
### final 实例字段
- final 修饰符对于类型为基本类型和不可变类的字段尤其有用。
  不可变类指类中的所有方法都不会改变其对象，如String
- final 修饰可变的类，需要理解 final 只是表示存储在变量的对象
  引用不会指示到另一个不同的对象上，不过这个对象可以更改
```java
        final StringBuffer name = new StringBuffer("1");
        name.append("2");
        System.out.println(name);
```
- - -

## 静态字段与静态方法
### 静态字段
- 将类的一个字段定义为 static，所有该类的对象都共享这个静态字段，
  非静态字段每个对象都有自己的一个副本。即使没有这个类的对象，
  静态字段也存在。它属于类，不属于任何单个的对象。
  没有static关键字，就会变成实例常量，必须通过类的对象来访问。
```java
private static int nextId = 1;
private int id;
public void setId(){
  id = nextId;
  nextId++;
}
```
### 静态常量
- 最好不要有公共字段，但公共常量没问题。
### 静态方法
- 静态方法不使用其类的对象，它没有隐式参数。
- 可以认为静态对象是没有this参数的方法。
- 静态方法不能访问实例字段，不能在对象上执行操作。
- 静态方法可以访问静态字段。
- *可以使用对象调用静态方法，但容易造成混淆，因为静态方法的计算结果与对象毫无关系，不建议使用*
- 使用静态方法的两种情况
  - 方法不需要访问对象状态，它需要的所有参数都通过显示参数提供。
  - 方法只需要访问类的静态字段。
### 工厂方法
- 静态方法的另一种常见用途，类似NumberFormat的类使用静态工厂方法来构造对象。
- 构造对象不使用构造器而使用工厂方法的主要两个原因
  - 构造器必须与类型相同，无法命名多个不同名字的构造器
  - 构造器无法改变构造对象的类型。
### main 方法
- main 方法不对任何对象进行操作。事实上，在启动程序时还没有
  任何对象。静态的 main 方法将执行并构造所需的的对象。
- 可以在类中使用 main 方法来做单元测试。
- - - 

## 方法参数
- 参数传递给方法的方式
  - 按值调用：方法接收的是调用者的值。
  - 按引用调用：方法接收的是调用者提供的变量地址。
- Java 采用的是按值调用。方法得到的是所有参数数值的一个副本。
- 两种类型的方法参数
  - 基本数据类型：这种比较好理解，方法是不可能修改基础类型的参数，
    参数会为传递的变量初始化一个副本，
    方法只是修改这副本，方法结束后，副本不再使用，
    原来的变量仍然不变。
  - 对象引用：可能会有点混淆，觉得对象采用的是按引用调用
    实际上，还是按值调用，可以理解方法初始化了一个对象引用的副本，
    这个副本和原来对象变量都引用了同一个对象，所以方法可以
    通过参数变量对引用的对象进行改变，但无法让一个对象参数引用另一个新的对象，
    即无法改变对象变量的引用。
  - ```java
    //比如无法实现2个对象变量互换
    public static void swap(Emp x, Emp y){
      Emp temp = x;
      x = y;
      y = temp;
    } 

    public static void test(){
      Emp a = new Emp("张三");
      Emp b = new Emp("李四");
      //执行后，a,b中的引用没有改变
      this.swap(a, b);
    }
    ```
## 对象构造
### 重载（overloading）
- 类可以有多个构造器，像这种出现多个方法有相同名字、不同参数，
  便出现了重载。编译器会根据所使用的参数类型进行匹配，匹配不到会
  发生编译错误，查找匹配的过程称为*重载解析*（overloading resolution）.
- 要完整描述一个方法，需要指定方法名以及参数类型，这叫方法的**签名**.
  如 indexOf(int)、indexOf(String)...
- 重载实际上是通过参数的编译类型而不是运行类型作为判定依据的。
### 默认字段初始化
- 构造器中没有显式地为字段设置初值，就会被自动地赋默认值：
  数值为0、布尔值为false、对象引用为null。
  依赖默认值是一种不好的编程实践，会影响程序代码的可读性。
- 字段与局部变量的区别，方法中的局部变量必须明确初始化，
  类中的字段没有初始化，将会自动初始化默认值。
### 无参数的构造器
- 有无参构造器创建对象时，对象的状态会设置为适当的默认值
  - ```java
    public Emp(){
      name = "";
      age = 0;
    }
    ```
- 如果一个类没有编写构造器，就会默认一个无参数构造器，
  这个构造器会将所有的实例字段设置为默认值。
- 如果类中提供至少一个构造器，但没有提供无参数构造器，
  那么构造对象不提供参数就不合法。
- 如果已编写了一个构造器，又需要通过new ClassName构造实例，
  如果希望所有字段被赋予默认值，只需这样编写即可
  - ```java
    public void ClassName(){}
    ```
### 显式字段初始化
```java
class Emp
{
  private int age = 18;
  ...
}
```
- 不管怎么调用构造器，每个实例字段都设置一个有意义的值，这是一个好习惯。
### 调用另一个构造器
- 关键字 this 指示一个方法的隐式参数，这个关键字还有另一个含义，就是可以调用另一个构造器。


```java
public Emp(int age){
  this("老王", age);
}
```
### 初始化块
- 只要构造类的对象，就会执行块
- 静态的初始化块可以初始化静态字段。
- 类第一次加载的时候，会进行静态字段的初始化，与实例字段一样，
  除非将静态字段显式地设置为特定值，否则默认初始值。
  所有静态字段初始化方法已经静态代码块将依照类声明中出现的顺序执行。
- - -

## 包
### 包名
- 为了保存包名的绝对唯一性，要用一个因特网域名以逆序的形式作为包名。
  com.horstmann.工程名
### 类的导入
- 如果没有在源文件中放置package语句，这个源文件中的类属于无名包。
- javac com/myproject/test.java
  java com.myproject.test
  编译器处理文件（带文件分隔符和扩展名.java文件）
  java解释器加载类（带.分隔符）
- P138的警告
### 包访问
- 如果没有修饰符（public/private）,这个部分（类、方法或变量）
  可以被同一个包中的所有方法访问。
### 类路径 ？
- - -

## JAR文件
- Java归档（JAR）文件既可以包含类文件，也可以包含诸如
  图像和声音等其他类型的文件。JAR 文件使用了ZIP压缩格式。
### 创建 JAR 文件
- jar cvf jarFileName.jar file1 file2...
  查阅 jar 程序选项
### 清单文件 ？
### 可执行 JAR 文件 ？
### 多版本 JAR 文件 ？
- - -

## 文档注释
- JDK 工具 javadoc,它可以由源文件生成一个HTML文档。
  在源代码中添加特殊界定符 /** 开始的注释，可以生成一个文档。
- javadoc -d f:\\temp\doc -author -version ChangeChar.java
- javadoc 标签
### 注释的插入
- javadoc 从下面几项中抽取信息
  - 模块
  - 包
  - 公共类和接口
  - 公共的和受保护的构造器和方法
  - 公共的和受保护的字段
- /** ...*/文档注释包含标记（@开头）以及之后的自由格式文本。
  自由格式文本第一句应该是一个概括性的句子，javadoc工具
  自动地将这些句子抽取出来生成概要页。
### 类注释
- 放在 import 语句之后，类定义之前。
```java
/**
* 注释概要
没有必要为每一行前面加*，
不过，大部分IDE会自动提供*号。
*/
public class Test(){
}
```
### 方法的注释
### 字段注释
- 只需要对公共字段（通常指静态常量）建立文档。
```java
/**
* 注释
*/
public static final int number = 1;
```
### 通用注释
- @since test 始于，如，@since 1.7.1
- @see 超链接
- 其他
### 包注释
- 提供一个名为 package-info.java 的 Java 文件。这个文件
  必须包含一个初始的以/**...*/界定的 javadoc 注释，后面
  是一个 package 语句。它不能包含更多的代码或注释。
- 提供一个名为 package.html 的HTML 文件。会抽取标记
  \<body>...\</body>之间的所有文本。
### 注释抽取 P151
- - -

## 类设计技巧
1. 一定要保证数据私有。
2. 一定要对数据进行初始化。
3. 不要在类中使用过多的基础类型。
4. 不是所有的字段都需要单独的字段访问器和字段变更器。
5. 分解有过多职责的类。
6. 类名和方法名要能够体现它们的职责。
7. 优先使用不可变的类。
- - -

# 继承
## 类、超类和子类
### 定义子类
- 关键字 extends 表明构造一个新类派生于一个已存在的类。
  这个已存在的类称为超类（superclass）、基类（base class）或
  父类（parent class）；新类称为子类（subclass）、
  派生类（derived class）或孩子类（child class）。
### 覆盖方法
- 覆盖（override）方法需要注意,子类无法直接使用父类私有字段，
  需要使用父类的公共接口，要使用关键字super调用。
- super 和 this 引用是不同的概念，super 不是一个对象的
  引用，例如，不能将 super 值赋给其他对象变量，它只是
  一个指示编译器调用超类方法的特殊关键字。
### 子类构造器
- 子类的构造器不能访问父类的私有字段，使用必须通过一个
  构造器来初始化这些私有字段。使用 super 调用构造器的语句
  必须是子类的构造器的第一条语句。
- 子类没有显式地调用超类构造器，将自动调用超类的无参数构造器。
  如果超类没有无参数构造器，子类又没有显式地调用超类的其他
  构造器，Java编译器会报错。
- this 和 super
  - this 的两个含义
    - 指示隐式参数的引用
    - 调用当前类的其他构造器
  - super 的两个含义
    - 调用超类方法；
    - 调用超类构造器
  - 在调用构造器时，两者紧密相关，调用构造器的语句只能作为
    另一个构造器的第一条语句出现。
- 一个对象变量可以指示多种实际类型的现象称为多态（polymorphism），
  在运行时能够自动地选择适当的方法，称为动态绑定（dynamic binding）。
### 继承层次
- 由一个超类派生出来的所有类的集合称为继承层次（inheritance hierarchy）。
  从某个特定的类到其祖先的路径称为该类的继承链（inheritance chain）。
- Java 不支持多重继承。
### 多态
- “is-a”规则
  - 用来判断是否应该将数据设计为继承关系，它指出子类的
    每个对象也是超类的对象，反之则不然。
  - “is-a”规则的另一种表述是**替换原则**，指程序中出现的
    超类对象的任何地方都可以使用子类对象替换。
    - ```java
      //子类对象可以赋给超类变量
      Employee m1 
      m1 = new Employee("老王");
      m1 = new Manage("张三");
      ```
- ***对象变量*** 是多态的（ploymorphic），一个超类的变量可以引用
  超类的对象，也可以引用该超类的任何子类的对象。
  - ```java
    Manage m1 = new Manage("老王");
    Employee[] staff = new Employee[];
    staff[0] = m1; //编译器只将 staff[0] 看成一个 Employee 对象。
    staff[0].setBonus(100);//无法调用子类的方法，ERROR
    ```
- 警告，子类引用的数组可以转换成超类引用的数组，而不需要使用强制
  类型转换。但是编译器允许为转换后的超类数组放置一个引用超类对象
  的变量，这导致子类数组与超类数组引用了同一个超类对象，当子类数组
  中的变量可能会调用一个不存在的实例字段，进而搅乱相邻存储空间的
  内容。
  为了确保不发生这类破坏，所有数组都要牢记创建时到元素类型。
  - ```java
        Manage m1 = new Manage("老王");
        Manage m2 = new Manage("张三");
        Manage[] manages = new Manage[]{m1, m2};

        Employee[] emps = manages;
        Employee e1 = new Employee("小李");
        emps[0] = e1;//引发 ArrayStoreException 异常，编译器只允许引用在类中声明的方法。
    ```

### 理解方法调用
1. 编译器查看对象的声明和方法，列举类和其超类中所有同名且可访问的访问。
2. 编译器确定方法调用中提供的参数类型，匹配参数类型完全匹配的方法，这个
   过程称为重载解析。允许类型转换。如果没有找到参数类型匹配的方法，
   或者经过转换后有多个方法匹配，编译器会报错。
   至此，编译器已经知道要调用方法的名字和参数类型。
   > 方法名称和参数列表称为方法的**签名**，返回类型不是签名的一部分。
   覆盖一个方法时，需要保证返回类型的兼容性。允许子类将覆盖方法的
   返回类改为原返回类型的子类型。可说这两个方法有**可协变**的返回类型。
3. 静态绑定：private方法、static方法、final方法或者构造器，编译器可以准确地
   知道应该调用哪个方法。
   动态绑定：要调用的方法依赖隐式参数的实际类型，那么必须在运行时使用动态绑定。
4. 程序运行并且采用动态绑定调用方法时，虚拟机必须调用变量所引用对象的
   实际类型对应的那个方法。子类定义了所调用的方法，就调用这个方法，否则
   将在超类中寻找方法。
- 方法表？ P164
- 动态绑定的重要特性：无需对现有的代码进行修改就可以对程序进行扩展？
> 警告：在覆盖一个方法的时候，子类方法**不能低于**超类方法的**可见性**。
### 阻止继承：final 类和方法
- 不能继承的类被称为 final 类，定义类的时候使用 final 修饰符。
- 类中的某个方法也可以被声明为 final，子类将不能覆盖这个方法。
  final 类的所有方法自动地成为 final 方法。
  > final 字段，构造对象之后就不允许改变它们的值，如果将一个类
  声明为 final，只有其中的方法自动地成为 final,而不包括字段。
- 将方法或类声明为 final 的主要原因：确保它们不会在子类中改变语义。
- 内联（inlining）:如果一个方法没有被覆盖并且很短，编译器就能对其
  进行优化处理。例如内联调用 e.getName() 将会被替换为访问字段e.name。
  如果getName在另一个类中被覆盖，编译器无法知道覆盖的代码做了什么
  操作，因此就不能对它进行内联处理。
- 即时编译器。
### 强制类型转换
- 唯一原因：要在暂时忽视对象的实际类型之后使用对象的所有功能。
  如，暂时将一个对象存到一个超类类型的数组之后，要访问其全部功能，
  就要将对象强制转换为子类类型。
- 将一个值存入变量是，编译器将检查你是否承诺过多。子类的引用赋给
  超类变量，编译器是允许的。父类变量赋给子类就承诺过多，必须进行
  强制类型转换。
  - ```java
    //在继承链上进行向下强制类型转换，运行时会产生ClassCastException异常
    Employee e1 = new Employee("小李");
    Manage m = (Manage) e1;
    
    //养成良好的程序设计习惯，在进行强制类型转换前，判断是否能转换成功
    if(e1 instanceof Manage){
      Manage m = (Manage) e1;
    }
    ```
- 总结
  - 只能在继承层次内进行强制类型转换
  - 在将超类强制类型转换成子类之前，应该使用 instanceof 进行检查。
```java
        Employee e1 = new Employee("小李", 5000.00);
        Employee e2 = new Manage("小李", 8000.00, 5000);
        //不需要强制类型转换，因为实现多态性的动态绑定机制能够自动地找到正确的方法。
        //Employee 的 getSalary() 只返回工资 5000
        System.out.println(e1.getName() + " 工资：" + String.valueOf(e1.getSalary()));
        //Manage 的 getSalary() 会返回工资+提成 13000
        System.out.println(e2.getName() + " 工资：" + String.valueOf(e2.getSalary()));
```
- 只有使用 Manage 特有方法才需要进行强制类型转换。
### 抽象类
- 使用 abstract 关键字，可以完全不需要实现这个方法。
  包含一个或多个抽象方法的类本身也必须被声明为抽象的。
  抽象类还可以包含字段和具体方法。
  > 有些程序员认为，在抽象类中不能包含具体方法，建议尽量将通用
  的字段和方法放在超类（不管是否抽象类）中。
- 扩展抽象类有种选择
  - 在子类中保留抽象类中的部分或所有抽象方法仍未定义，这样就必须
    将子类也标记为抽象类；
  - 定义全部方法，这样子类就不是抽象的了。
- 不含抽象方法也可以将类声明为抽象类
- 抽象类不能实例化
- 可以定义抽象类的对象变量，但只能引用非抽象子类的对象。
- abstract 必须可以没子类重写，否则就无法实现了，所以和其他修饰符组合需注意：
  - abstract 和 final 不能共同修饰方法，final 方法不能被重写。
  - abstract 和 private 不能共同修饰方法，private 方法不能被子类访问。
  - abstract 和 static 不能共同修饰方法，static表示是静态的方法，随着类的加载而加载，则该方法不需要在子类中去实现。
- 特点
  1. 抽象类中可以构造方法
  2. 抽象类中可以存在普通属性，方法，静态属性和方法。
  3. 抽象类中可以存在抽象方法。
  4. 如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。
  5. 抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。

### 受保护访问
- 用 protected 声明字段或方法为受保护的，只允许子类访问。
  谨慎使用受保护字段。
- Java中的4种访问修饰符
  1. 仅对本类可见——private。
  2. 对外部完全可见——public。
  3. 对本包和所有子类可见——protected。
  4. 对本包可见——默认，不需要修饰符。
- - -

## Object:所有类的超类
- Object 类是 Java 中所有类的始祖。如果没有明确地指定超类，Object 就
  被认为是这个类的超类。
### Object 类型的变量
- Object 类型的变量可以引用如何类型的对象。
  Object obj = new Employee("老王");
  Object 只是作为各种值的泛型容器。
  在 Java 中，只有基本类型不是对象。
  所有数组类型，包括基本类型的数组都扩展了 Object 类。
### equals 方法 ？
### 相等测试与继承 ？
### hashCode ？
### toString
- 只要对象与一个字符串通过操作符 “+” 连接起来，编译器就会自动调用toString方法。
Manage m = new Manage("小李", 8000.00, 5000);
System.out.println("经理:" + m);
> x.toString() 可以写作 ""+x,即使x是基本类型，这条语句也照样能执行。

> **警告**：数组继承了 Object 类的 toString 方法，数组直接调用会生成类似字符串 "[I@f35fe3" (前缀 [I 表明是一个整型数组)。
> 补救方法是调用Arrays.toString。

- toString 是非常有用的调试工具，能够获取一些有关对象状态的有用信息，如显示日志信息：
  System.out.println("Current position:" + position);
> 强烈建议为每个自定义类添加 toString 方法，可以日志记录支持中受益匪浅。
- - -

## 泛型数组列表
- ArrayList 是一个有**类型参数**的泛型类（generic class）。
### 声明数组列表
- Java 10 中，最好使用 var 关键字避免重复写类型
- 没有 var 关键字，可以省去右边的类型参数。
  - ```java 
    ArrayList<Employee> staff = new ArrayList<>();
    ```
- 使用 add 方法可以将一个元素添加到数组列表中。
  数组列表管理着一个内部的对象引用数组，如果调用 add 而内部数组已满了，数组列表会自动创建一个更大的数组。
- 可以在填充数组前调用 ensureCapacity 方法，分配一个包含n个对象的内部数组，这样前n次 add 就不会带来开销很大的重新分配空间。
- 数组列表确认不再发生变化，可以调用 trimToSize 方法。这个方法将存储块的大小调整为保存当前元素数量所需的存储空间。垃圾回收将回收多余的空间。
  削减数组列表大小后，添加新元素就需要再次移动存储块，所以确认不再添加元素后再使用 trimToSize。
### 访问数组列表元素
- 使用 get 和 set 访问或改变数组元素
> 警告：只有当数组列表的大小大于 i 时，才能调用.set(i, x)。
> 要使用 add 方法为数组添加新元素，而不是 set 方法，set 方法只是用来替换数组中的元素。
- toArray 方法将数组元素拷贝到一个数组中
- add(n, e) 位置 n 之后的所有元素都向后移动一位，为新元素留出空间。
- remove(n) 删除一个元素，位置 n 之后的所有元素都向前移动一位。
- - -

## 对象包装器与自动装箱
- 所有基础类型都有一个与之对应的包装器（wrapper）：Integer、Long、Float、Double、Short、Byte、Character 和 Boolean。
  包装器类是不可变的，一旦构造了包装器，就不允许更改包装在其中的值。包装类还是 final,不能派生子类。
- 尖括号中的类型参数不允许是基础类型，也就是要定义一个整型数组列表，需要用 Integer 包装类。
- 自动装箱（autoboxing）
  向 ArrayList\<Integer\> 添加 int 类型的元素
  list.add(3);
  将自动变成
  list.add(Integer.valueOf(3));
- 自动拆箱
  int n = list.get(i);
- ```java
        Integer i = 10;
        Integer i2 = i;
        System.out.println("i hashCode:" + i.hashCode()); //10
        System.out.println("i2 hashCode:" + i2.hashCode()); //10

        i++;  //自动拆箱，自动装箱
        System.out.println("i hashCode:" + i.hashCode()); //11
        //Integer 不可变，i2依然是10
        System.out.println("i2 hashCode:" + i2.hashCode()); //10
  ```
- 比较两个包装类是调用 equals 方法。
- 包装类可以引用 null。
- 混用 Integer 和 Double 类型， Integer 值会拆箱，提升未 double,再装箱为 Double。
- 装箱和拆箱是编译器的工作，不是虚拟机。编译器在生成类的字节码时会插入必要的方法调用。虚拟机只是执行了这些字节码。
- - -

## 参数数量可变的方法（变参（varargs）方法）
```java
//可以是基本类型
public Integer getMax(Integer... values){}
``` 
- 如果一个已有方法的最后一个参数是数组，可以把它重新定义为有可变参数的方法，而不会破坏已有的代码。
- - - 

## 枚举类？
- toString
- valueOf
- ordinal
- compareTo
- - -

## 反射（先跳过）
- - -

## 继承的设计技巧
1. 将公共存在和字段放在超类中。
2. 不要使用受保护的字段。
3. 使用继承实现 “is-a” 关系。
4. 除非所有继承的方法都有意义，否则不要使用继承。
5. 在覆盖方法时，不要改变预期的行为。
6. 使用多态，不要使用类型信息。
7. 不要滥用反射。
- - -

# 接口、lambda 表达式与内部类
## 接口
### 接口的概念
- 接口不是类，而是对希望符合这个接口的类的一组需求。
- 接口中所有方法都自动是 public 方法。因此，在接口中声明方法时，不必提供关键字 public。
- 接口中绝对不会有实例字段，在 Java8 之前，接口中绝对不会实现方法。
  可以将接口看成是没有实例字段的抽象类，但两个概念还有一定的不同。
- Arrays.sort(Object[] a)要让一个类使用排序服务必须让它实现 compareTO 方法。
### 接口的属性
- 接口不能构造接口对象，却能声明接口的变量：
  Comparable x;
- instanceof 可以校验一个对象是否属于某个特定类，也可以检查一个对象是否实现了某个特定接口。
- 接口可以进行扩展，从通用性较高的接口扩展到专用性较高的接口。
- 与接口的方法都会自动被设置为 public 一样，接口中的字段总是 public static final。
- 每个类只有一个超类，但可以实现多个接口。

### 特点
  1. 在接口中只有方法的声明，没有方法体。
  2. 在接口中只有常量，因为定义的变量，在编译的时候都会默认加上 public static final 
  3. 在接口中的方法，永远都被public来修饰。
  4. 接口中没有构造方法，也不能实例化接口的对象。
  5. 接口可以实现多继承
  6. 接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法，则实现类定义为抽象类。

### 静态和私有方法
- Java 8 中，允许在接口中增加静态方法。
- Java 9 中，接口中的方法可以是 private。
### 默认方法
- 用 default 修饰。
- ```java
  public interface Test {
    int age = 1;
    default int getAfterYear(int year){return age + year;};

    int size();
    //默认方法可以调用其他方法,这样就不需要再去操心 isEmpty 的实现了。
    default boolean isEmpty(){return size() == 0}
  }
  ```

- 接口演化
  接口增加了一个新方法，那么它的实现类将不能被编译。为接口增加非默认方法不能保证 “源代码兼容”。
  如果不重新编译(原先的JAR包中包含这个类)，这个类仍能正常加载。不过，如果在这个类实例上调用 steam 方法，就会出现一个 AbstractMethodError。
### 解决默认方法冲突
- 如果接口中一个默认方法和超类或另一个接口中定义相同，规则：
  1. 超类优先（“类优先” 规则）。
  2. 接口冲突（至少有一个接口提供了一个实现，即其他接口没有默认实现，也会造成冲突），必须覆盖这个方法来解决冲突。
### 接口与回调
- 回调（callback）是一种常见的程序设计模式。在这种模式中，可以指定某个时间发生是应该抽取的动作
- Timer、ActionListener
### Comparator 接口
- 对一个对象数组排序，前提是这些对象是实现了 Comparator 接口的类的实例。
- 一个类不可能用两种不同的方法实现 compareTo 方法，Arrays.sort 提供了另一个版本，参数为一个数组和一个比较器，比较强实现了 Comparator接口。
### 对象克隆
- 浅克隆
- 深克隆
- Object 类中的 clone 方法声明为 protected,子类必须重新定义为 public 才能允许所有方法克隆对象。
- 实现 Cloneable 接口,它没有指定 clone 方法，这个方法是从 Object 类继承的。
这个接口只是作为一个标记，指示类设计者理解克隆过程，如果没有实现这个接口，对象克隆请求克隆时，就会生成一个检查型异常。
- Cloneable 是一个标记接口
- 即使 clone 的默认实现能够满足要求，还是要实现 Cloneable 接口，将方法重新定义为 public。
- > 协变返回类型，可以为 clone 指定一个正确的返回类型。
- - -

## lambda 表达式
- lambda 表达式就是一个代码块，以及必须传入代码的变量规范。
```java
// lambda 表达式形式：参数,箭头以及一个表达式
(String first, String second)
  -> first.length() - second.length()

//如果一个表达式中无法完成计算，可以把代码放在{}中，并包含显式的 return 语句
(String first, String second) -> 
{
  return first.length() - second.length()
}
//没有参数，也要提供空括号
() -> {...}
//如果可以推导出参数类型，可以忽略其类型
//如果方法只有一个参数，而且这个参数的类型可以推导得出，可以省略小括号
ActionListener listener = event ->
  System.out.println("the time is " + Instant.ofEpochMilli(event.getWhen()));
//无须指定返回类型。
``` 
> 如果 lambda 表达式存在没有返回值的分支，这是不合法的。
### 函数式接口
- 对于**只有一个抽象方法**的接口，需要这种接口的对象时，可以提供一个 lambda 表达式。这种接口称为函数式接口（functional interface）。
  最后把 lambda 表达式看作是一个函数，而不是一个对象。
  lambda 表达式所能做的只是转换为函数是接口。
- 通用的函数式接口
  - BiFunction\<T, U, R\>
  - Predicate\<T\>
  - Supplier\<T\>,实现懒计算
### 方法引用 ？？
- var timer = new Timer(1000, System.out::println)
  System.out::println 是一个方法引用（method reference），它指示编译器生成一个函数式接口的实例，覆盖这个接口的抽象方法来调用给定的方法。
> 类似于 lambda 表达式，方法引用不是一个对象。不过，为一个类型为函数式接口的变量赋值是会生成一个对象。
- 对字符串进行排序，不考虑字母的大小写：
  Arrays.sort(strings, String::compareToIgnoreCase)
  用 :: 运算符分隔方法名与对象或类名。主要有3中情况
  1. object::instanceMethod
  2. Class::instanceMethod
  3. Class::staticMethod
- 当 lambda 表达式的体只调用一个方法而不做其他操作时，才能把 lambda 表达式重写为方法引用。
### 构造器引用
### 变量作用域
- lambda 表达式有3个部分
  1. 一个代码块；
  2. 参数；
  3. 自由变量的值，指非参数且不在代码中定义的变量。
- lambda 表达式有一个自由变量，表示 lambda 表达式的数据结构必需存储自由变量的值，可以说它被 lambda 表达式捕获（captured）。
  > 代码块以及自由变量值有一个术语：闭包（closure）。
- 在 lambda 表达式中，只能引用值不会改变的变量。
- lambda 表达式中捕获的变量必须实际上是**事实最终变量**（effectively final）。
- lambda 表达式的体与嵌套块有相同的作用域。
### 处理 lambda 表达式
- 使用 lambda 表达式的重点是延迟执行（deferred execution）。需要延迟执行代码的原因：
  - 在一个单独的线程中允许代码。
  - 多次允许代码。
  - 在算法的适当位置允许代码。
  - 发生某种情况是执行代码。
  - 只在必要时才允许代码。
- 常用函数式接口
- 基本类型的函数式接口
- 设计自定义的接口时，可以用 @FunctionalInterface 注解来标记接口，优点：
  - 当增加另一个抽象方法时，编译器会报错。
  - javadoc 会指出接口是函数式接口。
### Comparator
```java
//对要比较的对象应用这个函数，然后对返回的键完成比较。如，按名称排序
Arrays.sort(people, Comparator.comparing(Person::getName));
//thenComparing 处理比较结果相同的情况，如名字相同比较姓。
Arrays.sort(people, Comparator.comparing(Person::getLastName)
  .thenComparing(Person::getFirstName));
//按名称长短比较
Arrays.sort(people, Comparator.comparing(Person::getName,
  (s, t) -> Integer.compare(s.length(), t.length())));
//comparing, thenComparing 方法都有变形体，可以简化上一条语句
Arrays.sort(people, Comparator.comparingInt(p -> p.getName.length()));
``` 
- nullsFirst 和 nullsLast
- naturalOrder
- reverseOrder
- - -

## 内部类
- 需要内部类的原因
  - 内部类可以对同一个包中的其他类隐藏
  - 内部类方法可以访问定义这个类的作用域中的数据，包括私有的数据。
### 使用内部类访问对象状态
- 一个内部类可以访问自身的数据字段，也可以访问创建它的外围类对象的数据字段。
- 内部类有一个隐式引用，指向创建它的外部类对象（outer）。
- 编译器会修改所有的内部类构造器，添加一个对应外部类引用的参数。
> 只有内部类可以声明为私有，而常规类可以有包可见性（默认）或公共可见性。
> 内部类访问权限修饰符可以为：public、protected、默认、private；
> 常规类访问权限修饰符只能为：public、默认。
### 内部类的特殊语法规则
- 外部类引用的正规语法
  OuterClass.this
- 反过来编写内部类对象的构造器
  outerObject.new InnerClass(construction parameters)
### 局部内部类
- 声明局部类时不能访问说明符（public、private）。作用域被限制在声明的块中。
- 优势：对外界完全隐蔽。
### 由外部方法访问变量
- 局部类可以访问局部变量（必须是事实最终变量）。了解原理
### 匿名内部类
- new SuperType(construction param){
    inner class methods and data
  }
- SuperType 可以是接口，也可以是一个类。
- 因为构造器必须与类名相同，所以匿名内部类不能有构造器（可以提供一个对象初始化块）。
> 技巧：双括号初始化。

> 警告：getClass() != other.getClass()

> 提示：生成日志或调试消息时，希望包含当前类名，如：
> 使用 this.getClass();
> 这在静态方法中不奏效，可以使用
> new Object(){}.getClass().getEnclosingClass()
> 建立 Object 的匿名子类的一个匿名对象，getEnclosingClass 得到其外围类。
### 静态内部类
- 不需要内部类有外部类对象的一个引用，可以将内部类声明为 static。
- 要静态方法中调用，必须使用静态内部类。
> 静态内部类可以有静态字段和方法，常规类不能。
> 接口中声明的内部类自动是 static 和 public。
- - -

## 服务加载?
- - -

## 代理（proxy）??
- - -

# 异常、断言和日志
## 处理错误
- 出现错误而使得某些操作没有完成，程序应该：
  - 返回到一直安全状态，并能够让用户执行其他命令；
  - 允许用户保存所有工作的结果，并以妥善的方式终止程序。
### 异常分类
- 所有异常都由 Throwable 继承而来
  - Error：Java 运行时系统的内部错误和资源耗尽错误。对这种错误几乎无能为力。
  - **Exception**
    - RuntimeException：由编程错误导致的异常（一定是自己程序造成的）；
      - 错误的强制类型转换。
      - 数组访问越界。
      - 访问 null 指针。
    - 其他异常（I/O 错误）。
      - 试图超越文件末尾继续读取数据。
      - 试图打开一个不存在的文件
      - 试图根据给定的字符串查找 Class 对象，而这个字符串表示的类并不存在。
- 非检查型异常：派生于 Error 或 RuntimeException 类的所有异常。
- 检查型异常：其他所有异常。
### 声明检查型异常
- 不需要声明 Java 的内部错误，即 Error 继承的异常。任何错误代码都可能抛出，对此完全无法控制。
- 不需要声明从 RuntimeException 继承的非检查型异常（应该修正这些错误，而不是抛出）。
- 方法必须声明所有可能抛出的检查型异常，也可以捕获异常。
> 警告：子类覆盖超类的一个方法，子类方法中声明的检查型异常不能比超类方法中声明的异常更通用（子类抛出更特定的异常或不抛出任何异常）。
> 超类没有抛出任何检查型异常，子类也不能抛出任何检查型异常。
### 抛出异常
- 如果已有异常类能够满足要求：
  - 找到一个合适的异常类。
  - 创建这个类的一个对象。
  - 将对象抛出。
### 捕获异常
- 如果方法中的任何代码抛出了 catch 子句中没有的异常类型，那么这个方法会立即退出。
- 将异常交给胜任的处理器进行处理比压制这个异常更好。
### 捕获多个异常
- 可以为每个异常类型使用一个单独的 catch 子句，对不同类型异常做出不同处理。
- e.getMessage()：得到异常详细信息；
  e.getClass().getName()：得到异常对象的实际类型。
- java 7 中，一个 catch 子句可以捕获多个异常类型。只有当捕获的异常类型彼此之间不存在子类关系才需要这个特性。
> 捕获多个异常时，异常变量隐含为 final 变量。
### 再次抛出异常与异常链
- catch 中可以抛出异常，建议把原始异常设置为新异常的原因，这样不会丢失原始异常的细节：
  try{}
  catch(SQLException original){
    var e = new ServletException("err");
    e.initCause(original);
    throw e;
  }
  捕获该异常时，可以捕获原始异常：
  Throwable original = caughtException.getCause();
### finally 子句
- try 语句可以只有 finally 子句，而没有 catch 子句。
  这样如果遇到异常，异常将被重新抛出，并且必须由另一个 catch 子句捕获。
  内层的 catch 确保清理资源，外层的 catch 确保报告出现的错误。这种解决方案不仅清楚，而且功能强大：将会报告 finally 子句中出现的错误。
> 警告：finally 中包含 return 语句时，会将原来的返回值覆盖，甚至吞掉 try 块中出现的异常。
> finally 子句的体要用于清理资源。不要使用改变控制流的语句（return，throw，break,continue）
### try-with-Resources 语句 ？
### 分析堆栈轨迹元素
- 堆栈轨迹（stack trace）是程序执行过程中某个特定点上所有挂起的方法调用的一个列表。
```java
//可以调用 Throwable 类的 printStackTrace 方法访问堆栈轨迹的文本描述信息
Throwable t = new Throwable();
StringWriter out = new StringWriter();
t.printStackTrace(new PrintWriter(out));
String desc = out.toString();
```
- StackWalker ?
- - -

## 使用异常的技巧
1. 异常处理不能替代简单的测试。
   - 异常相比简单的测试所花费的时间会大大增加，使用异常的基本规则是：只在异常情况下使用异常。
2. 不要过分地细化异常
   - 将正常处理与财务处理分开。
3. 充分利用异常层次结构 ？
4. 不要压制异常
5. 在检测错误时，“苛刻”要比放任更好
6. 不要羞于传递异常。
> 早抛出，晚捕获。
- - -

## 使用断言
### 断言的概念
- 在测试中给程序加入检查，测试完毕后检查的代码会保留在程序中。
  if(x < 0)
    throw new Exception("x<0");
  如果程序中含有大量这种检查,程序运行会变慢很多。
  断言机制允许在测试期间向代码中插入一些检查，而生产代码中会自动删除这些检查。
- assert 关键字，有两种形式
  - assert condition
  - assert condition : expression
### 启用和禁用断言
- 断言默认是禁用的。在运行程序时用 -enableassertions 或 -ea 选项启用断言。
- 启用或禁用断言是类加载器的功能，不必重新编译程序。禁用断言时，类加载器会去除断言代码，因此不会降低程序运行的速度。
- 没有类加载器的系统类，需要使用 -enablesystemassertions/-esa 开关启用断言。
- - -
## 日志？
- - -

# 泛型程序设计
## 使用泛型程序设计的原因
### 类型参数的好处
- 相比 Object 类型的参数更加安全。
- - -

## 定义简单泛型类
- 泛型类（generic class）就是有一个或多个类型变量的类。泛型类相当于一个普通工厂
  public class<T>{...}
  public class<T, U>{...}
- 类型变量在整个类定义中用于指定方法的返回类型以及字段和局部变量的类型。
> 常见的做法是类型变量使用大写字母，且很简短。
> Java 库中：
> E：集合元素的类型
> K和V：键和值
> T：任意类型。
- - -

## 泛型方法
- 泛型方法的类型变量放在修饰符的后面，返回类型的前面。
  public static <T> T getMiddle(T... a){...}
- 调用泛型方法时，可以把具体类型包围在尖括号中，放在方法名前，也可以省略尖括号，编译器有足够的信息去推断
  ArrayAlg.<String>getMiddle("2","s");
- - -

## 类型变量的限定
- 限定实现某个接口的类
  public static <T extends Comparable> T min(T[] a){...}
  一个类型变量或通配符可以有多个限定,限定类型用 “&” 分隔。如果一个类作为限定，它必须放在限定列表的第一个。
  T extends Comparable & Serializable
- - -

## 泛型代码和虚拟机
- 虚拟机没有泛型类型对象——所有对象都属于普通类型
### 类型擦除
- 定义一个泛型类型，会自动提供一个相应的原始类型。类型变量会被擦除，并替换为其限定类型。原始类型用第一个限定类型来替换类型变量，或者，没有给定限定，就替换为 Object。
> 有多个限定时，编译器在必要时会向限定列表靠后的类型插入强制类型转换。为提高效率，应该将标签接口（即没有方法的接口）放在限定列表的末尾。
### 转换泛型表达式
- 编写一个泛型方法调用或访问泛型字段时，如果擦除返回类型或字段类型，编译器会在结果字节码中插入强制类型转换。
### 转换泛型方法 ？
- 桥方法
- Java 代码不能编写两个有相同参数类型的方法。但是虚拟机会由参数类型和返回类型共同指定一个方法。因此，编译器可以为两个仅返回类型不同的方法生成字节码，虚拟机能够正确地处理这种情况。
- 对于 Java 泛型的转换，需要记住几个事实
  - 虚拟机中没有泛型，只有普通的类和方法。
  - 所有的类型参数都会替换为他们的限定类型。
  - 会合成桥方法来保持多态。
  - 为保持类型安全性，必要时会插入强制类型转换。
### 调用遗留代码
- - -

## 限制与局限性
### 不能用基本类型实例化类型参数
- 由于类型擦除，擦除后会含有 Object 类型，而 Object 类型不能存储 double 值。
### 运行时类型查询只适用于原始类型
- 虚拟机中的对象总有一个特定的非泛型类型。因此，所有的类型查询只产生原始类型，如
  if(a instanceof ArrayList<String>) // ERROR
  或者强制类型转换。
- getClass 方法总返回原始类型。
### 不能创建参数化类型的数组？
